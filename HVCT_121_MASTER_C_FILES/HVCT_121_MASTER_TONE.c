#include<p24fj512gu408.h>
#include "../HVCT_121_MASTER_H_FILES/hvct_121_master_common_includes.h"


//#define TONE            PORTAbits.RA10

#define TONE_NUMBER_INVALID_ERROR					0x8D	// Tone number Not Valid
#define CMD_LAST_CMD_EXECUTE_SUCCESS				0x2F	// Last command executed Successfully.






unsigned char FLAG_CMD_RECEIVED=0;// This flag is set when complete command with data is received.
                                    // FLAG_CMD_RECEIVED = 0 = Complete Command with STOP bit, is not received yet.
                                    // FLAG_CMD_RECEIVED = 1 = Complete Command with STOP bit, is received.
unsigned int 	DATA_BYTES_CNT = 0;		// This variable contains the value of number of bytes to be sent to master.
//unsigned char 	MS_RECEIVED_ADD_I2C1 		= 0;	// Variable to copy received Slave Address byte, which is received on I2C1.	
unsigned char 	MS_RECEIVED_WR_ADD_I2C1 		= 0;	// Variable to copy received Slave WRITE Address byte, which is received on I2C1.	
unsigned char 	MS_RECEIVED_RD_ADD_I2C1 		= 0;	// Variable to copy received Slave READ Address byte, which is received on I2C1.	
unsigned char 	MS_RECEIVED_COMMAND_I2C1 	= 0; 	// Variable to copy received Command byte, which is received by I2C1 from Master to Slave.
unsigned char 	MS_RECEIVED_DATA_I2C1 	= 0; 	// Variable to copy received Data byte, which is received by I2C1 from Master to Slave.
unsigned char 	MS_RECEIVED_COMMAND_I2C2 	= 0; 	// Variable to copy received Command byte, which is received by I2C2 from Master to Slave.
unsigned char 	MS_RECEIVED_DATA_I2C2	 	= 0; 	// Variable to copy received Data byte, which is received by I2C2 from Master to Slave.

unsigned char	SUCCESS_CMD	= 0;		// The SUCCESS command will be saved in this ragister, which will be generated after any successful command execution
unsigned char 	ERROR_CMD_USB = 0;		// The error command will be saved in this ragister, which is generated by any USB related function.
unsigned char 	ERROR_CMD_OTHER = 0;	// The error command will be saved in this ragister, which is generated by any other function.
unsigned char 	STATE = 0;			// In Command_Parser function after each power ON first state is '0' for switch case.		

char			*DBUFR_START_ADD;		// This will point to the 0th location of DATA_BUFR,
char			*DBUFR_END_ADD;			// This will point to the last significant location of DATA_BUFR,
    
unsigned int TMR2_soft = 0,TMR3_soft = 0,PR2_soft = 0x0001,PR3_soft = 0x0001;
unsigned char beep = 0;
unsigned int beat_speed = 0;			// 2 byte variable
unsigned short int Duration_Counter = 0;		// 2 byte variable    
    
extern unsigned char FLAG_CMD_RECEIVED;
extern unsigned int TMR2_soft,TMR3_soft,PR2_soft,PR3_soft;
extern unsigned char beep;
extern unsigned int beat_speed;			// 2 byte variable
extern unsigned short int Duration_Counter;		// 2 byte variable

extern unsigned int 	DATA_BYTES_CNT;			
//extern unsigned char MS_RECEIVED_ADD_I2C1;	
extern unsigned char MS_RECEIVED_WR_ADD_I2C1;	
extern unsigned char MS_RECEIVED_RD_ADD_I2C1;	
extern unsigned char MS_RECEIVED_COMMAND_I2C1; 	
extern unsigned char MS_RECEIVED_DATA_I2C1; 	

extern unsigned char MS_RECEIVED_COMMAND_I2C2; 	
extern unsigned char MS_RECEIVED_DATA_I2C2; 	

extern unsigned char SUCCESS_CMD;		
extern unsigned char ERROR_CMD_USB;		
extern unsigned char ERROR_CMD_OTHER;	
extern unsigned char STATE;					

extern char			*DBUFR_START_ADD;		
extern char			*DBUFR_END_ADD;			
//---------- For testing purpose every tone is made to half time of original -----------------------------------//	
// PASS_1 Tone 1.24sec.
const static unsigned char PASS_1_Melody[] 			= {"32c,32c5,32c,32c5,32c,32c5,32c,32c5,32c,32c5,32c,32c5,32c,32c5,32c,32c5"};
const static unsigned int PASS_1_defaultoctave 		= 4;
const static unsigned int PASS_1_defaultduration 	= 1;
const static unsigned int PASS_1_beat_speed 		= 400;

// PASS_2 Tone 1.24sec.
const static unsigned char PASS_2_Melody[] 			= {"32c5,32c6,32c5,32c6,32c5,32c6,32c5,32c6,32c5,32c6,32c5,32c6,32c5,32c6,32c5,32c6"};
const static unsigned int PASS_2_defaultoctave 		= 4;
const static unsigned int PASS_2_defaultduration 	= 1;
const static unsigned int PASS_2_beat_speed 		= 400;

// PASS_3 Tone 1.24sec.
const static unsigned char PASS_3_Melody[] 			= {"32c6,32C7,32c6,32C7,32c6,32C7,32c6,32C7,32c6,32C7,32c6,32C7,32c6,32C7,32c6,32C7"};
const static unsigned int PASS_3_defaultoctave 		= 4;
const static unsigned int PASS_3_defaultduration 	= 1;
const static unsigned int PASS_3_beat_speed 		= 400;

// PASS_4 Tone 1.24sec.
const static unsigned char PASS_4_Melody[] 			= {"32c,32C7,32c,32C7,32c,32C7,32c,32C7,32c,32C7,32c,32C7,32c,32C7,32c,32C7"};
const static unsigned int PASS_4_defaultoctave 		= 4;
const static unsigned int PASS_4_defaultduration 	= 1;
const static unsigned int PASS_4_beat_speed 		= 450;

// FAIL_1 Tone 1.40sec.
const static unsigned char FAIL_1_Melody[] 			= {"c,c5"};
const static unsigned int FAIL_1_defaultoctave 		= 4;
const static unsigned int FAIL_1_defaultduration 	= 4;
const static unsigned int FAIL_1_beat_speed 		= 400;

// FAIL_2 Tone 1.40sec.
const static unsigned char FAIL_2_Melody[] 			= {"c5,c6"};
const static unsigned int FAIL_2_defaultoctave 		= 4;
const static unsigned int FAIL_2_defaultduration 	= 4;
const static unsigned int FAIL_2_beat_speed 		= 400;

// FAIL_3 Tone 1.40sec.
const static unsigned char FAIL_3_Melody[] 			= {"c6,c7"};
const static unsigned int FAIL_3_defaultoctave 		= 4;
const static unsigned int FAIL_3_defaultduration 	= 4;
const static unsigned int FAIL_3_beat_speed 		= 400;

// FAIL_4 Tone 1.40sec.
const static unsigned char FAIL_4_Melody[] 			= {"c,c7"};
const static unsigned int FAIL_4_defaultoctave 		= 4;
const static unsigned int FAIL_4_defaultduration 	= 4;
const static unsigned int FAIL_4_beat_speed 		= 400;
//---------- End of For testing purpose every tone is made to half time of original ----------------------------//

void Gen_Tone(unsigned char which_tone, unsigned char Tone_Time)
{
	unsigned int 	note = 0;
	const unsigned char * Melody = 0;	//unsigned char 	*Melody = 0;
	unsigned int 	pointer = 0;		// 4 byte variable.
	unsigned char 	octave = 0;
	unsigned char 	duration = 0;
	unsigned char 	defaultoctave = 0;
	unsigned char 	defaultduration = 0;

	beep = 0;
	Duration_Counter = 0;
	
	//---------- TONE Selection ----------------------------------------------------------------------------------------------------//	
		switch(which_tone)
		{
			case 1	: // PASS_1 Tone
						Melody = PASS_1_Melody;	
						defaultoctave = PASS_1_defaultoctave;
						defaultduration = PASS_1_defaultduration;
						beat_speed = PASS_1_beat_speed;
						break;
			case 2	: // PASS_2 Tone
						Melody = PASS_2_Melody;
						defaultoctave = PASS_2_defaultoctave;
						defaultduration = PASS_2_defaultduration;
						beat_speed = PASS_2_beat_speed;
						break;
			case 3	: // PASS_3 Tone
						Melody = PASS_3_Melody;
						defaultoctave = PASS_3_defaultoctave;
						defaultduration = PASS_3_defaultduration;
						beat_speed = PASS_3_beat_speed;
						break;
			case 4	: // PASS_4 Tone
						Melody = PASS_4_Melody;
						defaultoctave = PASS_4_defaultoctave;
						defaultduration = PASS_4_defaultduration;
						beat_speed = PASS_4_beat_speed;			
						break;
			case 5	: // FAIL_1 Tone
						Melody = FAIL_1_Melody;
						defaultoctave = FAIL_1_defaultoctave;
						defaultduration = FAIL_1_defaultduration;
						beat_speed = FAIL_1_beat_speed;
						break;
			case 6	: // FAIL_2 Tone
						Melody = FAIL_2_Melody;
						defaultoctave = FAIL_2_defaultoctave;
						defaultduration = FAIL_2_defaultduration;
						beat_speed = FAIL_2_beat_speed;
						break;
			case 7	: // FAIL_3 Tone
						Melody = FAIL_3_Melody;
						defaultoctave = FAIL_3_defaultoctave;
						defaultduration = FAIL_3_defaultduration;
						beat_speed = FAIL_3_beat_speed;
						break;
			case 8	: // FAIL_4 Tone
						Melody = FAIL_4_Melody;
						defaultoctave = FAIL_4_defaultoctave;
						defaultduration = FAIL_4_defaultduration;
						beat_speed = FAIL_4_beat_speed;			
						break;
			default	: // Do nothing.
//						STATE = 128;	// Goto state 128 to send the error command to Master.
//						ERROR_CMD_OTHER = TONE_NUMBER_INVALID_ERROR;	// Send Master a ERROR Command saying Tone Number Not Valid.
//						FLAG_CMD_RECEIVED = 0;
//						MS_RECEIVED_COMMAND_I2C1 = 0;
//						MS_RECEIVED_WR_ADD_I2C1 = 0;
//						MS_RECEIVED_RD_ADD_I2C1 = 0;
						break;		
		}	
	//--------------------------------------------------------------------------------------------------------------//
	
	if(!ERROR_CMD_OTHER)	// If tone data is aquired properly then get in the loop.
	{
		while(Tone_Time--)		// Play the Tone Tone_Time times in this while loop.
		{
		    do		// Play the Tone once in this do-while loop. 
			{
		        octave = defaultoctave; 	/* Set Default Octave */
		//---------- Duration Searching ---------------------------------------------------------------------------------//	
		        if ((Melody[pointer] == '3') && (Melody[pointer+1] == '2')) 
			    {
		            duration = 32;
		            pointer += 2;
		        }
		        else if ((Melody[pointer] == '1') && (Melody[pointer+1] == '6')) 
			    {
		            duration = 16;
		            pointer += 2;
		        }
		        else if (Melody[pointer] == '8') 
			    {
		            duration = 8;
		            pointer++;
		        }
		        else if (Melody[pointer] == '4') 
			    {
		            duration = 4;
		            pointer++;
		        }
		        else if (Melody[pointer] == '2') 
			    {
		            duration = 2;
		            pointer++;
		        }
		        else if (Melody[pointer] == '1') 
			    {
		            duration = 1;
		            pointer++;
		        }
		        else 
		        	duration = defaultduration;
		//--------------------------------------------------------------------------------------------------------------//
		//---------- Note Searching ------------------------------------------------------------------------------------//	
		
		  if (Melody[pointer + 1] == '#') 
			    {
		            /* Process Sharps */
		            
		            switch (Melody[pointer]) 
			        {
		                case 'a' : note = 6438/8.25;
		                           break;
		                           
		                case 'c' : note = 10822/8.25;
		                           break;
		                           
		                case 'd' : note = 9644/8.25;
		                           break;
		                           
		                case 'f' : note = 8108/8.25;
		                           break;
		                           
		                case 'g' : note = 7224/8.25;
		                           break;
		            }
		            pointer +=2;
		        }
		        else 
		        {
		            switch (Melody[pointer]) 
			        {
		                case 'a' : note = 6818/8.25;
		                           break;
		                case 'b' : note = 6074/8.25;
		                           break;
		                case 'c' : note = 11469/8.25;
		                           break;
		                case 'd' : note = 10214/8.25;
		                           break;
		                case 'e' : note = 9103/8.25;    
		                           break;
		                case 'f' : note = 8591/8.25;
		                           break;
		                case 'g' : note = 7653/8.25;
		                           break;
		                case 'p' : note = 0;
		                           break;
		            }
		            pointer++;
		        }   
		//--------------------------------------------------------------------------------------------------------------//
		//---------- Duration made to be 1.5 times or not ? ------------------------------------------------------------//	       
		        if (Melody[pointer] == '.')
			    {
		            /* Duration 1.5x */
		            duration = duration + 128;
		            pointer++;
		        }
		        else;
		//--------------------------------------------------------------------------------------------------------------//
		//---------- Octave Sreaching --------------------------------------------------------------------------------------------------//	
		        if (Melody[pointer] == '4') 
			    {
		            octave = 4;
		            pointer++;
		        } 
		        else if (Melody[pointer] == '5') 
			    {
		            octave = 5;
		            pointer++;
		        }
		        else if (Melody[pointer] == '6') 
			    {
		            octave = 6;
		            pointer++;
		        } 
		        else if (Melody[pointer] == '7') 
		        {
		            octave = 7;
		            pointer++;
		        }
		        else; 
		//--------------------------------------------------------------------------------------------------------------//
		//---------- Duration made to be 1.5 times or not ? ------------------------------------------------------------//	       
		        if (Melody[pointer] == '.') 
			    {
		            /* Duration 1.5x */
		            duration = duration + 128;
		            pointer++;
		        }
		        else;
		//--------------------------------------------------------------------------------------------------------------//
	
		        PlayNote(note, octave, duration,beat_speed);
		
		    }while (Melody[pointer++] == ',');		// Play the Tone once in this do-while loop.
		    
		//----------- Wait until last note has played ------------------------------------------------------------------//		
			while(Duration_Counter)
		    {	    
				TMR2_soft++;
			
			    if(TMR2_soft == PR2_soft)
			 	{   
					TMR2_soft = beat_speed;
			        if (Duration_Counter) Duration_Counter--;
				}
				else;
				
				TMR3_soft++;
				
				if (TMR3_soft == PR3_soft)
				{
					if(beep)
                    {
                      
						TONE = !TONE;
                       
                    }    
					else
						TONE = 0;
						
					TMR3_soft = 0;
				}
				else;					
			} 
			
			beep = 0;
	   		pointer = 0;
		//--------------------------------------------------------------------------------------------------------------//   		
	   	}  	//END of 'while(Tone_Time--)' loop.
//	 	
//	 	STATE = 126;
//	 	SUCCESS_CMD = CMD_LAST_CMD_EXECUTE_SUCCESS;
//	 	FLAG_CMD_RECEIVED = 0;
//		MS_RECEIVED_COMMAND_I2C1 = 0;
//		MS_RECEIVED_WR_ADD_I2C1 = 0;
//		MS_RECEIVED_RD_ADD_I2C1 = 0;
//	 	
	}	// End of if(!ERROR_CMD_OTHER) loop.
	else;	// Do Nothing. ERROR is occured and according ERROR_CMD_OTHER and STATE registers are updated,
			// so procede to terminate the loop.		
 	
}	// End of Gen_Tone function.


//--------------------------------------------------------------------------------------------------------------//
/*	Function:	
		void PlayNote(unsigned int note_temp, unsigned char octave_temp, unsigned int duration_temp,unsigned int beat_speed_temp);
    
  	Description:
    	This is 
    	This function will generate PASS and FAIL tones.
  	
  	Precondition:
   		A command to play PASS or FAIL tone must be received from Master.
   		
  	Input parameter:
		which_tone 	= Which tone is to be played from 8 hard coded tones. 
		Tone_Time	= For what how much seconds the tone is to played.
	
	Output:
		TEMP_BYTE_6 = The returned int value of FSerror(), is saved to TEMP_BYTE_6, for conversion of int to char.
		
  	Return Values:
   		NIL.
   	Error raised:
   		
   	Functions called:
   	
   	Variable Distruction::
   		TEMP_BYTE_5
   		TEMP_BYTE_6
   		TEMP_DOUBLE_5
   	
   	Remarks:
    	nil.
*/
//--------------------------------------------------------------------------------------------------------------//

void PlayNote(unsigned int note_temp, unsigned char octave_temp, unsigned int duration_temp,unsigned int beat_speed_temp)
{
	//--------- Process octave -----------------------------------------------------------------------------------//
	    switch (octave_temp) 
		{
	        case 4 :/* Do noting */
	        		break;
	             	
	        case 5 :/* %2 */
		            note_temp = note_temp >> 1; 
		            break;
		             
	        case 6 : /* %4 */
		            note_temp = note_temp >> 2;
		            break;
		             
	        case 7 : /* %8 */
		            note_temp = note_temp >> 3;
		            break;
	    }
	//--------------------------------------------------------------------------------------------------------------//
	//--------- Wait until last note has played --------------------------------------------------------------------//
	    while(Duration_Counter)
	    {	    
			TMR2_soft++;
		
		    if(TMR2_soft == PR2_soft)
		 	{   
				TMR2_soft = beat_speed_temp;
		        if (Duration_Counter) Duration_Counter--;
			}
			else;
			
			TMR3_soft++;
			
			if (TMR3_soft == PR3_soft)
			{
				if(beep)
					TONE = !TONE;
				else
					TONE = 0;
					
				TMR3_soft = 0;
			}
			else;					
		} 
	    beep = 0;
	//--------------------------------------------------------------------------------------------------------------//
	//---------- Process New Note Frequency ------------------------------------------------------------------------//
	    if (note_temp) 
	    {
			PR3_soft = note_temp;
			TMR3_soft = 0;
		}
	    else;
	//--------------------------------------------------------------------------------------------------------------//
	//---------- Process Note Duration -----------------------------------------------------------------------------//    

	    Duration_Counter = 255/(duration_temp & 0x7F);
	
	    /* If duration is 1.5x add .5 to duration */
	    if (duration_temp & 0x80) 
			Duration_Counter = (Duration_Counter + (Duration_Counter >> 1));    
		else;
		
		TMR2_soft = beat_speed_temp;
		PR2_soft = 0x0CFF;	// If you feel tone playing speed is faster than expected then you can decrease speed
							// by increasing PR2_soft in multiple of 0x0100.
	//--------------------------------------------------------------------------------------------------------------//
	//----------- Start sounding the new Note ----------------------------------------------------------------------//
	    if (note_temp)
	    {
			beep = 1;
		}
		else;
	//--------------------------------------------------------------------------------------------------------------//
}

//--------------------------------------------------------------------------------------------------------------//
/*	Function:	
		void MS_CHANGE_TONE(unsigned char which_tone, unsigned char Tone_Time);
    
  	Description:
    	This function will play the required PASS and FAIL tone for required time.
  	
  	Precondition:
		NIL.   		
  	Input parameter:
		which_tone 	= Which tone is to be played from 8 hard coded tones.
		Tone_Time	= For what how much seconds the tone is to played.
	
	Output:
		NIL.		
  	Return Values:
   		NIL.
   	Error raised:
   		NIL.
   	Functions called:
   		Gen_Tone
   		
   	Variable Distruction::
		NIL.   	
   	Remarks:
    	Here Command expected from Master is 
			0xE0,0x62,0x01,seconds or 
		  	0xE0,0x62,0x01,seconds or 
		  	0xE0,0x62,0x01,seconds or 
		  	0xE0,0x62,0x01,seconds

	    After receiving the command, 2 thing that can happen
	    -	PASS tone of 'which_tone' number will be played. This ringing of tone will continue for 'Tone_Time' seconds.
	    	FAIL tone of ('which_tone'+4) number will be played for 'Tone_Time' seconds.
			If the second command received is 'ESC' then an SUCCESS_CMD will be 
			sent back to master.
		-	During the playing of tone if an ERROR is generated. Then tone will not be played .
			And after reception of 0xE1, the respective ERROR command will be sent to master.	

*/
//--------------------------------------------------------------------------------------------------------------//
void MS_CHANGE_TONE(unsigned char which_tone, unsigned char Tone_Time)
{
	Gen_Tone( which_tone, Tone_Time);	// Generate PASS tone.
	
	if(!ERROR_CMD_OTHER)	// If ERROR is not occured in PASS tone generation, then go in the loop.
	{
		DelayMs(500);	// JRT(Ver 1.70)
		Gen_Tone( (which_tone+4), Tone_Time );	// Generate FAIL tone.
	}
	else;	// Do Nothing. because	ERROR is occured in PASS tone generation.
	
	
//	if(!ERROR_CMD_OTHER)	// If ERROR is not occured in FAIL tone generation, then go in the loop.
//	{
//		STATE = 126;
//	 	SUCCESS_CMD = CMD_LAST_CMD_EXECUTE_SUCCESS;
//	 	FLAG_CMD_RECEIVED = 0;
//		MS_RECEIVED_COMMAND_I2C1 = 0;
//		MS_RECEIVED_WR_ADD_I2C1 = 0;
//		MS_RECEIVED_RD_ADD_I2C1 = 0;
//	}
//	else;	// Do Nothing. because	ERROR is occured in FAIL tone generation.
}	
